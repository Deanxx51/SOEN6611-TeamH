<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>PStmtKey.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">Apache Commons DBCP</a> &gt; <a href="index.source.html" class="el_package">org.apache.commons.dbcp2</a> &gt; <span class="el_source">PStmtKey.java</span></div><h1>PStmtKey.java</h1><pre class="source lang-java linenums">/*
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the &quot;License&quot;); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.commons.dbcp2;

import java.sql.Connection;
import java.sql.SQLException;
import java.sql.Statement;
import java.util.Arrays;

import org.apache.commons.dbcp2.PoolingConnection.StatementType;

/**
 * A key uniquely identifying {@link java.sql.PreparedStatement PreparedStatement}s.
 *
 * @since 2.0
 */
public class PStmtKey {

    /**
     * Builder for prepareCall(String sql).
     */
<span class="fc" id="L36">    private class PreparedCallSQL implements StatementBuilder {</span>
        @Override
        public Statement createStatement(final Connection connection) throws SQLException {
<span class="fc" id="L39">            return connection.prepareCall(sql);</span>
        }
    }

    /**
     * Builder for prepareCall(String sql, int resultSetType, int resultSetConcurrency).
     */
<span class="fc" id="L46">    private class PreparedCallWithResultSetConcurrency implements StatementBuilder {</span>
        @Override
        public Statement createStatement(final Connection connection) throws SQLException {
<span class="fc" id="L49">            return connection.prepareCall(sql, resultSetType.intValue(), resultSetConcurrency.intValue());</span>
        }
    }

    /**
     * Builder for prepareCall(String sql, int resultSetType, int resultSetConcurrency, int resultSetHoldability).
     */
<span class="fc" id="L56">    private class PreparedCallWithResultSetHoldability implements StatementBuilder {</span>
        @Override
        public Statement createStatement(final Connection connection) throws SQLException {
<span class="fc" id="L59">            return connection.prepareCall(sql, resultSetType.intValue(), resultSetConcurrency.intValue(),</span>
<span class="fc" id="L60">                    resultSetHoldability.intValue());</span>
        }
    }

    /**
     * Builder for prepareStatement(String sql).
     */
<span class="fc" id="L67">    private class PreparedStatementSQL implements StatementBuilder {</span>
        @Override
        public Statement createStatement(final Connection connection) throws SQLException {
<span class="fc" id="L70">            return connection.prepareStatement(sql);</span>
        }
    }

    /**
     * Builder for prepareStatement(String sql, int autoGeneratedKeys).
     */
<span class="fc" id="L77">    private class PreparedStatementWithAutoGeneratedKeys implements StatementBuilder {</span>
        @Override
        public Statement createStatement(final Connection connection) throws SQLException {
<span class="fc" id="L80">            return connection.prepareStatement(sql, autoGeneratedKeys.intValue());</span>
        }
    }

    /**
     * Builder for prepareStatement(String sql, int[] columnIndexes).
     */
<span class="fc" id="L87">    private class PreparedStatementWithColumnIndexes implements StatementBuilder {</span>
        @Override
        public Statement createStatement(final Connection connection) throws SQLException {
<span class="fc" id="L90">            return connection.prepareStatement(sql, columnIndexes);</span>
        }
    }

    /**
     * Builder for prepareStatement(String sql, String[] columnNames).
     */
<span class="fc" id="L97">    private class PreparedStatementWithColumnNames implements StatementBuilder {</span>
        @Override
        public Statement createStatement(final Connection connection) throws SQLException {
<span class="fc" id="L100">            return connection.prepareStatement(sql, columnNames);</span>
        }
    }

    /**
     * Builder for prepareStatement(String sql, int resultSetType, int resultSetConcurrency).
     */
<span class="fc" id="L107">    private class PreparedStatementWithResultSetConcurrency implements StatementBuilder {</span>
        @Override
        public Statement createStatement(final Connection connection) throws SQLException {
<span class="fc" id="L110">            return connection.prepareStatement(sql, resultSetType.intValue(), resultSetConcurrency.intValue());</span>
        }
    }

    /**
     * Builder for prepareStatement(String sql, int resultSetType, int resultSetConcurrency, int resultSetHoldability).
     */
<span class="fc" id="L117">    private class PreparedStatementWithResultSetHoldability implements StatementBuilder {</span>
        @Override
        public Statement createStatement(final Connection connection) throws SQLException {
<span class="fc" id="L120">            return connection.prepareStatement(sql, resultSetType.intValue(), resultSetConcurrency.intValue(),</span>
<span class="fc" id="L121">                    resultSetHoldability.intValue());</span>
        }
    }

    /**
     * Interface for Prepared or Callable Statement.
     */
    private interface StatementBuilder {
        Statement createStatement(Connection connection) throws SQLException;
    }

    /**
     * SQL defining Prepared or Callable Statement
     */
    private final String sql;

    /**
     * Result set type; one of &lt;code&gt;ResultSet.TYPE_FORWARD_ONLY&lt;/code&gt;, &lt;code&gt;ResultSet.TYPE_SCROLL_INSENSITIVE&lt;/code&gt;,
     * or &lt;code&gt;ResultSet.TYPE_SCROLL_SENSITIVE&lt;/code&gt;.
     */
    private final Integer resultSetType;

    /**
     * Result set concurrency. A concurrency type; one of &lt;code&gt;ResultSet.CONCUR_READ_ONLY&lt;/code&gt; or
     * &lt;code&gt;ResultSet.CONCUR_UPDATABLE&lt;/code&gt;.
     */
    private final Integer resultSetConcurrency;

    /**
     * Result set holdability. One of the following &lt;code&gt;ResultSet&lt;/code&gt; constants:
     * &lt;code&gt;ResultSet.HOLD_CURSORS_OVER_COMMIT&lt;/code&gt; or &lt;code&gt;ResultSet.CLOSE_CURSORS_AT_COMMIT&lt;/code&gt;.
     */
    private final Integer resultSetHoldability;

    /** Database catalog. */
    private final String catalog;

    /** Database schema. */
    private final String schema;

    /**
     * A flag indicating whether auto-generated keys should be returned; one of
     * &lt;code&gt;Statement.RETURN_GENERATED_KEYS&lt;/code&gt; or &lt;code&gt;Statement.NO_GENERATED_KEYS&lt;/code&gt;.
     */
    private final Integer autoGeneratedKeys;

    /**
     * An array of column indexes indicating the columns that should be returned from the inserted row or rows.
     */
    private final int[] columnIndexes;

    /**
     * An array of column names indicating the columns that should be returned from the inserted row or rows.
     */
    private final String[] columnNames;

    /**
     * Statement type, prepared or callable.
     */
    private final StatementType statementType;

    /** Statement builder */
    private transient StatementBuilder builder;

    /**
     * Constructs a key to uniquely identify a prepared statement.
     *
     * @param sql
     *            The SQL statement.
     * @deprecated Use {@link #PStmtKey(String, String, String)}.
     */
    @Deprecated
    public PStmtKey(final String sql) {
<span class="nc" id="L194">        this(sql, null, StatementType.PREPARED_STATEMENT);</span>
<span class="nc" id="L195">    }</span>

    /**
     * Constructs a key to uniquely identify a prepared statement.
     *
     * @param sql
     *            The SQL statement.
     * @param resultSetType
     *            A result set type; one of &lt;code&gt;ResultSet.TYPE_FORWARD_ONLY&lt;/code&gt;,
     *            &lt;code&gt;ResultSet.TYPE_SCROLL_INSENSITIVE&lt;/code&gt;, or &lt;code&gt;ResultSet.TYPE_SCROLL_SENSITIVE&lt;/code&gt;.
     * @param resultSetConcurrency
     *            A concurrency type; one of &lt;code&gt;ResultSet.CONCUR_READ_ONLY&lt;/code&gt; or
     *            &lt;code&gt;ResultSet.CONCUR_UPDATABLE&lt;/code&gt;.
     * @deprecated Use {@link #PStmtKey(String, String, String, int, int)}.
     */
    @Deprecated
    public PStmtKey(final String sql, final int resultSetType, final int resultSetConcurrency) {
<span class="nc" id="L212">        this(sql, null, resultSetType, resultSetConcurrency, StatementType.PREPARED_STATEMENT);</span>
<span class="nc" id="L213">    }</span>

    /**
     * Constructs a key to uniquely identify a prepared statement.
     *
     * @param sql
     *            The SQL statement.
     * @param catalog
     *            The catalog.
     * @deprecated Use {@link #PStmtKey(String, String, String)}.
     */
    @Deprecated
    public PStmtKey(final String sql, final String catalog) {
<span class="nc" id="L226">        this(sql, catalog, StatementType.PREPARED_STATEMENT);</span>
<span class="nc" id="L227">    }</span>

    /**
     * Constructs a key to uniquely identify a prepared statement.
     *
     * @param sql
     *            The SQL statement.
     * @param catalog
     *            The catalog.
     * @param autoGeneratedKeys
     *            A flag indicating whether auto-generated keys should be returned; one of
     *            &lt;code&gt;Statement.RETURN_GENERATED_KEYS&lt;/code&gt; or &lt;code&gt;Statement.NO_GENERATED_KEYS&lt;/code&gt;.
     * @deprecated Use {@link #PStmtKey(String, String, String, int)}.
     */
    @Deprecated
    public PStmtKey(final String sql, final String catalog, final int autoGeneratedKeys) {
<span class="nc" id="L243">        this(sql, catalog, StatementType.PREPARED_STATEMENT, Integer.valueOf(autoGeneratedKeys));</span>
<span class="nc" id="L244">    }</span>

    /**
     * Constructs a key to uniquely identify a prepared statement.
     *
     * @param sql
     *            The SQL statement.
     * @param catalog
     *            The catalog.
     * @param resultSetType
     *            A result set type; one of &lt;code&gt;ResultSet.TYPE_FORWARD_ONLY&lt;/code&gt;,
     *            &lt;code&gt;ResultSet.TYPE_SCROLL_INSENSITIVE&lt;/code&gt;, or &lt;code&gt;ResultSet.TYPE_SCROLL_SENSITIVE&lt;/code&gt;.
     * @param resultSetConcurrency
     *            A concurrency type; one of &lt;code&gt;ResultSet.CONCUR_READ_ONLY&lt;/code&gt; or
     *            &lt;code&gt;ResultSet.CONCUR_UPDATABLE&lt;/code&gt;.
     * @deprecated Use @link {@link #PStmtKey(String, String, String, int, int)}.
     */
    @Deprecated
    public PStmtKey(final String sql, final String catalog, final int resultSetType, final int resultSetConcurrency) {
<span class="nc" id="L263">        this(sql, catalog, resultSetType, resultSetConcurrency, StatementType.PREPARED_STATEMENT);</span>
<span class="nc" id="L264">    }</span>

    /**
     * Constructs a key to uniquely identify a prepared statement.
     *
     * @param sql
     *            The SQL statement.
     * @param catalog
     *            The catalog.
     * @param resultSetType
     *            a result set type; one of &lt;code&gt;ResultSet.TYPE_FORWARD_ONLY&lt;/code&gt;,
     *            &lt;code&gt;ResultSet.TYPE_SCROLL_INSENSITIVE&lt;/code&gt;, or &lt;code&gt;ResultSet.TYPE_SCROLL_SENSITIVE&lt;/code&gt;.
     * @param resultSetConcurrency
     *            A concurrency type; one of &lt;code&gt;ResultSet.CONCUR_READ_ONLY&lt;/code&gt; or
     *            &lt;code&gt;ResultSet.CONCUR_UPDATABLE&lt;/code&gt;
     * @param resultSetHoldability
     *            One of the following &lt;code&gt;ResultSet&lt;/code&gt; constants: &lt;code&gt;ResultSet.HOLD_CURSORS_OVER_COMMIT&lt;/code&gt;
     *            or &lt;code&gt;ResultSet.CLOSE_CURSORS_AT_COMMIT&lt;/code&gt;.
     * @deprecated Use {@link #PStmtKey(String, String, String, int, int, int)}.
     */
    @Deprecated
    public PStmtKey(final String sql, final String catalog, final int resultSetType, final int resultSetConcurrency,
            final int resultSetHoldability) {
<span class="nc" id="L287">        this(sql, catalog, resultSetType, resultSetConcurrency, resultSetHoldability, StatementType.PREPARED_STATEMENT);</span>
<span class="nc" id="L288">    }</span>

    /**
     * Constructs a key to uniquely identify a prepared statement.
     *
     * @param sql
     *            The SQL statement.
     * @param catalog
     *            The catalog.
     * @param resultSetType
     *            a result set type; one of &lt;code&gt;ResultSet.TYPE_FORWARD_ONLY&lt;/code&gt;,
     *            &lt;code&gt;ResultSet.TYPE_SCROLL_INSENSITIVE&lt;/code&gt;, or &lt;code&gt;ResultSet.TYPE_SCROLL_SENSITIVE&lt;/code&gt;
     * @param resultSetConcurrency
     *            A concurrency type; one of &lt;code&gt;ResultSet.CONCUR_READ_ONLY&lt;/code&gt; or
     *            &lt;code&gt;ResultSet.CONCUR_UPDATABLE&lt;/code&gt;.
     * @param resultSetHoldability
     *            One of the following &lt;code&gt;ResultSet&lt;/code&gt; constants: &lt;code&gt;ResultSet.HOLD_CURSORS_OVER_COMMIT&lt;/code&gt;
     *            or &lt;code&gt;ResultSet.CLOSE_CURSORS_AT_COMMIT&lt;/code&gt;.
     * @param statementType
     *            The SQL statement type, prepared or callable.
     * @deprecated Use {@link #PStmtKey(String, String, String, int, int, int, PoolingConnection.StatementType)}
     */
    @Deprecated
    public PStmtKey(final String sql, final String catalog, final int resultSetType, final int resultSetConcurrency,
<span class="nc" id="L312">            final int resultSetHoldability, final StatementType statementType) {</span>
<span class="nc" id="L313">        this.sql = sql;</span>
<span class="nc" id="L314">        this.catalog = catalog;</span>
<span class="nc" id="L315">        this.schema = null;</span>
<span class="nc" id="L316">        this.resultSetType = Integer.valueOf(resultSetType);</span>
<span class="nc" id="L317">        this.resultSetConcurrency = Integer.valueOf(resultSetConcurrency);</span>
<span class="nc" id="L318">        this.resultSetHoldability = Integer.valueOf(resultSetHoldability);</span>
<span class="nc" id="L319">        this.statementType = statementType;</span>
<span class="nc" id="L320">        this.autoGeneratedKeys = null;</span>
<span class="nc" id="L321">        this.columnIndexes = null;</span>
<span class="nc" id="L322">        this.columnNames = null;</span>
        // create builder
<span class="nc bnc" id="L324" title="All 2 branches missed.">        if (statementType == StatementType.PREPARED_STATEMENT) {</span>
<span class="nc" id="L325">            this.builder = new PreparedStatementWithResultSetHoldability();</span>
<span class="nc bnc" id="L326" title="All 2 branches missed.">        } else if (statementType == StatementType.CALLABLE_STATEMENT) {</span>
<span class="nc" id="L327">            this.builder = new PreparedCallWithResultSetHoldability();</span>
        }
<span class="nc" id="L329">    }</span>

    /**
     * Constructs a key to uniquely identify a prepared statement.
     *
     * @param sql
     *            The SQL statement.
     * @param catalog
     *            The catalog.
     * @param resultSetType
     *            A result set type; one of &lt;code&gt;ResultSet.TYPE_FORWARD_ONLY&lt;/code&gt;,
     *            &lt;code&gt;ResultSet.TYPE_SCROLL_INSENSITIVE&lt;/code&gt;, or &lt;code&gt;ResultSet.TYPE_SCROLL_SENSITIVE&lt;/code&gt;.
     * @param resultSetConcurrency
     *            A concurrency type; one of &lt;code&gt;ResultSet.CONCUR_READ_ONLY&lt;/code&gt; or
     *            &lt;code&gt;ResultSet.CONCUR_UPDATABLE&lt;/code&gt;.
     * @param statementType
     *            The SQL statement type, prepared or callable.
     * @deprecated Use {@link #PStmtKey(String, String, String, int, int, PoolingConnection.StatementType)}.
     */
    @Deprecated
    public PStmtKey(final String sql, final String catalog, final int resultSetType, final int resultSetConcurrency,
<span class="nc" id="L350">            final StatementType statementType) {</span>
<span class="nc" id="L351">        this.sql = sql;</span>
<span class="nc" id="L352">        this.catalog = catalog;</span>
<span class="nc" id="L353">        this.schema = null;</span>
<span class="nc" id="L354">        this.resultSetType = Integer.valueOf(resultSetType);</span>
<span class="nc" id="L355">        this.resultSetConcurrency = Integer.valueOf(resultSetConcurrency);</span>
<span class="nc" id="L356">        this.resultSetHoldability = null;</span>
<span class="nc" id="L357">        this.statementType = statementType;</span>
<span class="nc" id="L358">        this.autoGeneratedKeys = null;</span>
<span class="nc" id="L359">        this.columnIndexes = null;</span>
<span class="nc" id="L360">        this.columnNames = null;</span>
        // create builder
<span class="nc bnc" id="L362" title="All 2 branches missed.">        if (statementType == StatementType.PREPARED_STATEMENT) {</span>
<span class="nc" id="L363">            this.builder = new PreparedStatementWithResultSetConcurrency();</span>
<span class="nc bnc" id="L364" title="All 2 branches missed.">        } else if (statementType == StatementType.CALLABLE_STATEMENT) {</span>
<span class="nc" id="L365">            this.builder = new PreparedCallWithResultSetConcurrency();</span>
        }
<span class="nc" id="L367">    }</span>

    /**
     * Constructs a key to uniquely identify a prepared statement.
     *
     * @param sql
     *            The SQL statement.
     * @param catalog
     *            The catalog.
     * @param columnIndexes
     *            An array of column indexes indicating the columns that should be returned from the inserted row or
     *            rows.
     * @deprecated Use {@link #PStmtKey(String, String, String, int[])}.
     */
    @Deprecated
<span class="nc" id="L382">    public PStmtKey(final String sql, final String catalog, final int[] columnIndexes) {</span>
<span class="nc" id="L383">        this.sql = sql;</span>
<span class="nc" id="L384">        this.catalog = catalog;</span>
<span class="nc" id="L385">        this.schema = null;</span>
<span class="nc" id="L386">        this.statementType = StatementType.PREPARED_STATEMENT;</span>
<span class="nc" id="L387">        this.autoGeneratedKeys = null;</span>
<span class="nc bnc" id="L388" title="All 2 branches missed.">        this.columnIndexes = columnIndexes == null ? null : Arrays.copyOf(columnIndexes, columnIndexes.length);</span>
<span class="nc" id="L389">        this.columnNames = null;</span>
<span class="nc" id="L390">        this.resultSetType = null;</span>
<span class="nc" id="L391">        this.resultSetConcurrency = null;</span>
<span class="nc" id="L392">        this.resultSetHoldability = null;</span>
        // create builder
<span class="nc" id="L394">        this.builder = new PreparedStatementWithColumnIndexes();</span>
<span class="nc" id="L395">    }</span>

    /**
     * Constructs a key to uniquely identify a prepared statement.
     *
     * @param sql
     *            The SQL statement.
     * @param catalog
     *            The catalog.
     * @param statementType
     *            The SQL statement type, prepared or callable.
     * @deprecated Use {@link #PStmtKey(String, String, String, PoolingConnection.StatementType)}.
     */
    @Deprecated
<span class="nc" id="L409">    public PStmtKey(final String sql, final String catalog, final StatementType statementType) {</span>
<span class="nc" id="L410">        this.sql = sql;</span>
<span class="nc" id="L411">        this.catalog = catalog;</span>
<span class="nc" id="L412">        this.schema = null;</span>
<span class="nc" id="L413">        this.statementType = statementType;</span>
<span class="nc" id="L414">        this.autoGeneratedKeys = null;</span>
<span class="nc" id="L415">        this.columnIndexes = null;</span>
<span class="nc" id="L416">        this.columnNames = null;</span>
<span class="nc" id="L417">        this.resultSetType = null;</span>
<span class="nc" id="L418">        this.resultSetConcurrency = null;</span>
<span class="nc" id="L419">        this.resultSetHoldability = null;</span>
        // create builder
<span class="nc bnc" id="L421" title="All 2 branches missed.">        if (statementType == StatementType.PREPARED_STATEMENT) {</span>
<span class="nc" id="L422">            this.builder = new PreparedStatementSQL();</span>
<span class="nc bnc" id="L423" title="All 2 branches missed.">        } else if (statementType == StatementType.CALLABLE_STATEMENT) {</span>
<span class="nc" id="L424">            this.builder = new PreparedCallSQL();</span>
        }
<span class="nc" id="L426">    }</span>

    /**
     * Constructs a key to uniquely identify a prepared statement.
     *
     * @param sql
     *            The SQL statement.
     * @param catalog
     *            The catalog.
     * @param statementType
     *            The SQL statement type, prepared or callable.
     * @param autoGeneratedKeys
     *            A flag indicating whether auto-generated keys should be returned; one of
     *            &lt;code&gt;Statement.RETURN_GENERATED_KEYS&lt;/code&gt; or &lt;code&gt;Statement.NO_GENERATED_KEYS&lt;/code&gt;.
     * @deprecated Use {@link #PStmtKey(String, String, String, PoolingConnection.StatementType, Integer)}
     */
    @Deprecated
    public PStmtKey(final String sql, final String catalog, final StatementType statementType,
<span class="nc" id="L444">            final Integer autoGeneratedKeys) {</span>
<span class="nc" id="L445">        this.sql = sql;</span>
<span class="nc" id="L446">        this.catalog = catalog;</span>
<span class="nc" id="L447">        this.schema = null;</span>
<span class="nc" id="L448">        this.statementType = statementType;</span>
<span class="nc" id="L449">        this.autoGeneratedKeys = autoGeneratedKeys;</span>
<span class="nc" id="L450">        this.columnIndexes = null;</span>
<span class="nc" id="L451">        this.columnNames = null;</span>
<span class="nc" id="L452">        this.resultSetType = null;</span>
<span class="nc" id="L453">        this.resultSetConcurrency = null;</span>
<span class="nc" id="L454">        this.resultSetHoldability = null;</span>
        // create builder
<span class="nc bnc" id="L456" title="All 2 branches missed.">        if (statementType == StatementType.PREPARED_STATEMENT) {</span>
<span class="nc" id="L457">            this.builder = new PreparedStatementWithAutoGeneratedKeys();</span>
<span class="nc bnc" id="L458" title="All 2 branches missed.">        } else if (statementType == StatementType.CALLABLE_STATEMENT) {</span>
<span class="nc" id="L459">            this.builder = new PreparedCallSQL();</span>
        }
<span class="nc" id="L461">    }</span>

    /**
     * Constructs a key to uniquely identify a prepared statement.
     *
     * @param sql
     *            The SQL statement.
     * @param catalog
     *            The catalog.
     * @param schema
     *            The schema
     * @since 2.5.0
     */
    public PStmtKey(final String sql, final String catalog, final String schema) {
<span class="fc" id="L475">        this(sql, catalog, schema, StatementType.PREPARED_STATEMENT);</span>
<span class="fc" id="L476">    }</span>

    /**
     * Constructs a key to uniquely identify a prepared statement.
     *
     * @param sql
     *            The SQL statement.
     * @param catalog
     *            The catalog.
     * @param schema
     *            The schema
     * @param autoGeneratedKeys
     *            A flag indicating whether auto-generated keys should be returned; one of
     *            &lt;code&gt;Statement.RETURN_GENERATED_KEYS&lt;/code&gt; or &lt;code&gt;Statement.NO_GENERATED_KEYS&lt;/code&gt;.
     * @since 2.5.0
     */
    public PStmtKey(final String sql, final String catalog, final String schema, final int autoGeneratedKeys) {
<span class="fc" id="L493">        this(sql, catalog, schema, StatementType.PREPARED_STATEMENT, Integer.valueOf(autoGeneratedKeys));</span>
<span class="fc" id="L494">    }</span>

    /**
     * Constructs a key to uniquely identify a prepared statement.
     *
     * @param sql
     *            The SQL statement.
     * @param catalog
     *            The catalog.
     * @param schema
     *            The schema
     * @param resultSetType
     *            A result set type; one of &lt;code&gt;ResultSet.TYPE_FORWARD_ONLY&lt;/code&gt;,
     *            &lt;code&gt;ResultSet.TYPE_SCROLL_INSENSITIVE&lt;/code&gt;, or &lt;code&gt;ResultSet.TYPE_SCROLL_SENSITIVE&lt;/code&gt;.
     * @param resultSetConcurrency
     *            A concurrency type; one of &lt;code&gt;ResultSet.CONCUR_READ_ONLY&lt;/code&gt; or
     *            &lt;code&gt;ResultSet.CONCUR_UPDATABLE&lt;/code&gt;.
     */
    public PStmtKey(final String sql, final String catalog, final String schema, final int resultSetType, final int resultSetConcurrency) {
<span class="fc" id="L513">        this(sql, catalog, schema, resultSetType, resultSetConcurrency, StatementType.PREPARED_STATEMENT);</span>
<span class="fc" id="L514">    }</span>

    /**
     * Constructs a key to uniquely identify a prepared statement.
     *
     * @param sql
     *            The SQL statement.
     * @param catalog
     *            The catalog.
     * @param schema
     *            The schema
     * @param resultSetType
     *            a result set type; one of &lt;code&gt;ResultSet.TYPE_FORWARD_ONLY&lt;/code&gt;,
     *            &lt;code&gt;ResultSet.TYPE_SCROLL_INSENSITIVE&lt;/code&gt;, or &lt;code&gt;ResultSet.TYPE_SCROLL_SENSITIVE&lt;/code&gt;.
     * @param resultSetConcurrency
     *            A concurrency type; one of &lt;code&gt;ResultSet.CONCUR_READ_ONLY&lt;/code&gt; or
     *            &lt;code&gt;ResultSet.CONCUR_UPDATABLE&lt;/code&gt;
     * @param resultSetHoldability
     *            One of the following &lt;code&gt;ResultSet&lt;/code&gt; constants: &lt;code&gt;ResultSet.HOLD_CURSORS_OVER_COMMIT&lt;/code&gt;
     *            or &lt;code&gt;ResultSet.CLOSE_CURSORS_AT_COMMIT&lt;/code&gt;.
     * @since 2.5.0
     */
    public PStmtKey(final String sql, final String catalog, final String schema, final int resultSetType, final int resultSetConcurrency,
            final int resultSetHoldability) {
<span class="fc" id="L538">        this(sql, catalog, schema, resultSetType, resultSetConcurrency, resultSetHoldability, StatementType.PREPARED_STATEMENT);</span>
<span class="fc" id="L539">    }</span>

    /**
     * Constructs a key to uniquely identify a prepared statement.
     *
     * @param sql
     *            The SQL statement.
     * @param catalog
     *            The catalog.
     * @param schema
     *            The schema.
     * @param resultSetType
     *            a result set type; one of &lt;code&gt;ResultSet.TYPE_FORWARD_ONLY&lt;/code&gt;,
     *            &lt;code&gt;ResultSet.TYPE_SCROLL_INSENSITIVE&lt;/code&gt;, or &lt;code&gt;ResultSet.TYPE_SCROLL_SENSITIVE&lt;/code&gt;
     * @param resultSetConcurrency
     *            A concurrency type; one of &lt;code&gt;ResultSet.CONCUR_READ_ONLY&lt;/code&gt; or
     *            &lt;code&gt;ResultSet.CONCUR_UPDATABLE&lt;/code&gt;.
     * @param resultSetHoldability
     *            One of the following &lt;code&gt;ResultSet&lt;/code&gt; constants: &lt;code&gt;ResultSet.HOLD_CURSORS_OVER_COMMIT&lt;/code&gt;
     *            or &lt;code&gt;ResultSet.CLOSE_CURSORS_AT_COMMIT&lt;/code&gt;.
     * @param statementType
     *            The SQL statement type, prepared or callable.
     * @since 2.5.0
     */
    public PStmtKey(final String sql, final String catalog, final String schema, final int resultSetType, final int resultSetConcurrency,
<span class="fc" id="L564">            final int resultSetHoldability, final StatementType statementType) {</span>
<span class="fc" id="L565">        this.sql = sql;</span>
<span class="fc" id="L566">        this.catalog = catalog;</span>
<span class="fc" id="L567">        this.schema = schema;</span>
<span class="fc" id="L568">        this.resultSetType = Integer.valueOf(resultSetType);</span>
<span class="fc" id="L569">        this.resultSetConcurrency = Integer.valueOf(resultSetConcurrency);</span>
<span class="fc" id="L570">        this.resultSetHoldability = Integer.valueOf(resultSetHoldability);</span>
<span class="fc" id="L571">        this.statementType = statementType;</span>
<span class="fc" id="L572">        this.autoGeneratedKeys = null;</span>
<span class="fc" id="L573">        this.columnIndexes = null;</span>
<span class="fc" id="L574">        this.columnNames = null;</span>
        // create builder
<span class="fc bfc" id="L576" title="All 2 branches covered.">        if (statementType == StatementType.PREPARED_STATEMENT) {</span>
<span class="fc" id="L577">            this.builder = new PreparedStatementWithResultSetHoldability();</span>
<span class="fc bfc" id="L578" title="All 2 branches covered.">        } else if (statementType == StatementType.CALLABLE_STATEMENT) {</span>
<span class="fc" id="L579">            this.builder = new PreparedCallWithResultSetHoldability();</span>
        }
<span class="fc" id="L581">    }</span>

    /**
     * Constructs a key to uniquely identify a prepared statement.
     *
     * @param sql
     *            The SQL statement.
     * @param catalog
     *            The catalog.
     * @param schema
     *            The schema.
     * @param resultSetType
     *            A result set type; one of &lt;code&gt;ResultSet.TYPE_FORWARD_ONLY&lt;/code&gt;,
     *            &lt;code&gt;ResultSet.TYPE_SCROLL_INSENSITIVE&lt;/code&gt;, or &lt;code&gt;ResultSet.TYPE_SCROLL_SENSITIVE&lt;/code&gt;.
     * @param resultSetConcurrency
     *            A concurrency type; one of &lt;code&gt;ResultSet.CONCUR_READ_ONLY&lt;/code&gt; or
     *            &lt;code&gt;ResultSet.CONCUR_UPDATABLE&lt;/code&gt;.
     * @param statementType
     *            The SQL statement type, prepared or callable.
     * @since 2.5.0
     */
    public PStmtKey(final String sql, final String catalog, final String schema, final int resultSetType, final int resultSetConcurrency,
<span class="fc" id="L603">            final StatementType statementType) {</span>
<span class="fc" id="L604">        this.sql = sql;</span>
<span class="fc" id="L605">        this.catalog = catalog;</span>
<span class="fc" id="L606">        this.schema = schema;</span>
<span class="fc" id="L607">        this.resultSetType = Integer.valueOf(resultSetType);</span>
<span class="fc" id="L608">        this.resultSetConcurrency = Integer.valueOf(resultSetConcurrency);</span>
<span class="fc" id="L609">        this.resultSetHoldability = null;</span>
<span class="fc" id="L610">        this.statementType = statementType;</span>
<span class="fc" id="L611">        this.autoGeneratedKeys = null;</span>
<span class="fc" id="L612">        this.columnIndexes = null;</span>
<span class="fc" id="L613">        this.columnNames = null;</span>
        // create builder
<span class="fc bfc" id="L615" title="All 2 branches covered.">        if (statementType == StatementType.PREPARED_STATEMENT) {</span>
<span class="fc" id="L616">            this.builder = new PreparedStatementWithResultSetConcurrency();</span>
<span class="fc bfc" id="L617" title="All 2 branches covered.">        } else if (statementType == StatementType.CALLABLE_STATEMENT) {</span>
<span class="fc" id="L618">            this.builder = new PreparedCallWithResultSetConcurrency();</span>
        }
<span class="fc" id="L620">    }</span>

    /**
     * Constructs a key to uniquely identify a prepared statement.
     *
     * @param sql
     *            The SQL statement.
     * @param catalog
     *            The catalog.
     * @param schema
     *            The schema.
     * @param columnIndexes
     *            An array of column indexes indicating the columns that should be returned from the inserted row or
     *            rows.
     */
<span class="fc" id="L635">    public PStmtKey(final String sql, final String catalog, final String schema, final int[] columnIndexes) {</span>
<span class="fc" id="L636">        this.sql = sql;</span>
<span class="fc" id="L637">        this.catalog = catalog;</span>
<span class="fc" id="L638">        this.schema = schema;</span>
<span class="fc" id="L639">        this.statementType = StatementType.PREPARED_STATEMENT;</span>
<span class="fc" id="L640">        this.autoGeneratedKeys = null;</span>
<span class="fc bfc" id="L641" title="All 2 branches covered.">        this.columnIndexes = columnIndexes == null ? null : Arrays.copyOf(columnIndexes, columnIndexes.length);</span>
<span class="fc" id="L642">        this.columnNames = null;</span>
<span class="fc" id="L643">        this.resultSetType = null;</span>
<span class="fc" id="L644">        this.resultSetConcurrency = null;</span>
<span class="fc" id="L645">        this.resultSetHoldability = null;</span>
        // create builder
<span class="fc" id="L647">        this.builder = new PreparedStatementWithColumnIndexes();</span>
<span class="fc" id="L648">    }</span>

    /**
     * Constructs a key to uniquely identify a prepared statement.
     *
     * @param sql
     *            The SQL statement.
     * @param catalog
     *            The catalog.
     * @param schema
     *            The schema.
     * @param statementType
     *            The SQL statement type, prepared or callable.
     * @since 2.5.0
     */
<span class="fc" id="L663">    public PStmtKey(final String sql, final String catalog, final String schema, final StatementType statementType) {</span>
<span class="fc" id="L664">        this.sql = sql;</span>
<span class="fc" id="L665">        this.catalog = catalog;</span>
<span class="fc" id="L666">        this.schema = schema;</span>
<span class="fc" id="L667">        this.statementType = statementType;</span>
<span class="fc" id="L668">        this.autoGeneratedKeys = null;</span>
<span class="fc" id="L669">        this.columnIndexes = null;</span>
<span class="fc" id="L670">        this.columnNames = null;</span>
<span class="fc" id="L671">        this.resultSetType = null;</span>
<span class="fc" id="L672">        this.resultSetConcurrency = null;</span>
<span class="fc" id="L673">        this.resultSetHoldability = null;</span>
        // create builder
<span class="fc bfc" id="L675" title="All 2 branches covered.">        if (statementType == StatementType.PREPARED_STATEMENT) {</span>
<span class="fc" id="L676">            this.builder = new PreparedStatementSQL();</span>
<span class="pc bpc" id="L677" title="1 of 2 branches missed.">        } else if (statementType == StatementType.CALLABLE_STATEMENT) {</span>
<span class="fc" id="L678">            this.builder = new PreparedCallSQL();</span>
        }
<span class="fc" id="L680">    }</span>

    /**
     * Constructs a key to uniquely identify a prepared statement.
     *
     * @param sql
     *            The SQL statement.
     * @param catalog
     *            The catalog.
     * @param schema
     *            The schema.
     * @param statementType
     *            The SQL statement type, prepared or callable.
     * @param autoGeneratedKeys
     *            A flag indicating whether auto-generated keys should be returned; one of
     *            &lt;code&gt;Statement.RETURN_GENERATED_KEYS&lt;/code&gt; or &lt;code&gt;Statement.NO_GENERATED_KEYS&lt;/code&gt;.
     * @since 2.5.0
     */
    public PStmtKey(final String sql, final String catalog, final String schema, final StatementType statementType,
<span class="fc" id="L699">            final Integer autoGeneratedKeys) {</span>
<span class="fc" id="L700">        this.sql = sql;</span>
<span class="fc" id="L701">        this.catalog = catalog;</span>
<span class="fc" id="L702">        this.schema = schema;</span>
<span class="fc" id="L703">        this.statementType = statementType;</span>
<span class="fc" id="L704">        this.autoGeneratedKeys = autoGeneratedKeys;</span>
<span class="fc" id="L705">        this.columnIndexes = null;</span>
<span class="fc" id="L706">        this.columnNames = null;</span>
<span class="fc" id="L707">        this.resultSetType = null;</span>
<span class="fc" id="L708">        this.resultSetConcurrency = null;</span>
<span class="fc" id="L709">        this.resultSetHoldability = null;</span>
        // create builder
<span class="fc bfc" id="L711" title="All 2 branches covered.">        if (statementType == StatementType.PREPARED_STATEMENT) {</span>
<span class="fc" id="L712">            this.builder = new PreparedStatementWithAutoGeneratedKeys();</span>
<span class="pc bpc" id="L713" title="1 of 2 branches missed.">        } else if (statementType == StatementType.CALLABLE_STATEMENT) {</span>
<span class="fc" id="L714">            this.builder = new PreparedCallSQL();</span>
        }
<span class="fc" id="L716">    }</span>

    /**
     * Constructs a key to uniquely identify a prepared statement.
     *
     * @param sql
     *            The SQL statement.
     * @param catalog
     *            The catalog.
     * @param schema
     *            The schema.
     * @param columnNames
     *            An array of column names indicating the columns that should be returned from the inserted row or rows.
     * @since 2.5.0
     */
<span class="fc" id="L731">    public PStmtKey(final String sql, final String catalog, final String schema, final String[] columnNames) {</span>
<span class="fc" id="L732">        this.sql = sql;</span>
<span class="fc" id="L733">        this.catalog = catalog;</span>
<span class="fc" id="L734">        this.schema = schema;</span>
<span class="fc" id="L735">        this.statementType = StatementType.PREPARED_STATEMENT;</span>
<span class="fc" id="L736">        this.autoGeneratedKeys = null;</span>
<span class="fc" id="L737">        this.columnIndexes = null;</span>
<span class="fc bfc" id="L738" title="All 2 branches covered.">        this.columnNames = columnNames == null ? null : Arrays.copyOf(columnNames, columnNames.length);</span>
<span class="fc" id="L739">        this.resultSetType = null;</span>
<span class="fc" id="L740">        this.resultSetConcurrency = null;</span>
<span class="fc" id="L741">        this.resultSetHoldability = null;</span>
        // create builder
<span class="fc" id="L743">        builder = new PreparedStatementWithColumnNames();</span>
<span class="fc" id="L744">    }</span>

    /**
     * Constructs a key to uniquely identify a prepared statement.
     *
     * @param sql
     *            The SQL statement.
     * @param catalog
     *            The catalog.
     * @param columnNames
     *            An array of column names indicating the columns that should be returned from the inserted row or rows.
     * @deprecated Use {@link #PStmtKey(String, String, String, String[])}.
     */
    @Deprecated
<span class="nc" id="L758">    public PStmtKey(final String sql, final String catalog, final String[] columnNames) {</span>
<span class="nc" id="L759">        this.sql = sql;</span>
<span class="nc" id="L760">        this.catalog = catalog;</span>
<span class="nc" id="L761">        this.schema = null;</span>
<span class="nc" id="L762">        this.statementType = StatementType.PREPARED_STATEMENT;</span>
<span class="nc" id="L763">        this.autoGeneratedKeys = null;</span>
<span class="nc" id="L764">        this.columnIndexes = null;</span>
<span class="nc bnc" id="L765" title="All 2 branches missed.">        this.columnNames = columnNames == null ? null : Arrays.copyOf(columnNames, columnNames.length);</span>
<span class="nc" id="L766">        this.resultSetType = null;</span>
<span class="nc" id="L767">        this.resultSetConcurrency = null;</span>
<span class="nc" id="L768">        this.resultSetHoldability = null;</span>
        // create builder
<span class="nc" id="L770">        builder = new PreparedStatementWithColumnNames();</span>
<span class="nc" id="L771">    }</span>

    /**
     * Creates a new Statement from the given Connection.
     *
     * @param connection
     *            The Connection to use to create the statement.
     * @return The statement.
     * @throws SQLException
     *             Thrown when there is a problem creating the statement.
     */
    public Statement createStatement(final Connection connection) throws SQLException {
<span class="pc bpc" id="L783" title="1 of 2 branches missed.">        if (builder == null) {</span>
<span class="nc" id="L784">            throw new IllegalStateException(&quot;Prepared statement key is invalid.&quot;);</span>
        }
<span class="fc" id="L786">        return builder.createStatement(connection);</span>
    }

    @Override
    public boolean equals(final Object obj) {
<span class="fc bfc" id="L791" title="All 2 branches covered.">        if (this == obj) {</span>
<span class="fc" id="L792">            return true;</span>
        }
<span class="fc bfc" id="L794" title="All 2 branches covered.">        if (obj == null) {</span>
<span class="fc" id="L795">            return false;</span>
        }
<span class="fc bfc" id="L797" title="All 2 branches covered.">        if (getClass() != obj.getClass()) {</span>
<span class="fc" id="L798">            return false;</span>
        }
<span class="fc" id="L800">        final PStmtKey other = (PStmtKey) obj;</span>
<span class="fc bfc" id="L801" title="All 2 branches covered.">        if (autoGeneratedKeys == null) {</span>
<span class="fc bfc" id="L802" title="All 2 branches covered.">            if (other.autoGeneratedKeys != null) {</span>
<span class="fc" id="L803">                return false;</span>
            }
<span class="fc bfc" id="L805" title="All 2 branches covered.">        } else if (!autoGeneratedKeys.equals(other.autoGeneratedKeys)) {</span>
<span class="fc" id="L806">            return false;</span>
        }
<span class="fc bfc" id="L808" title="All 2 branches covered.">        if (catalog == null) {</span>
<span class="pc bpc" id="L809" title="1 of 2 branches missed.">            if (other.catalog != null) {</span>
<span class="nc" id="L810">                return false;</span>
            }
<span class="fc bfc" id="L812" title="All 2 branches covered.">        } else if (!catalog.equals(other.catalog)) {</span>
<span class="fc" id="L813">            return false;</span>
        }
<span class="fc bfc" id="L815" title="All 2 branches covered.">        if (!Arrays.equals(columnIndexes, other.columnIndexes)) {</span>
<span class="fc" id="L816">            return false;</span>
        }
<span class="fc bfc" id="L818" title="All 2 branches covered.">        if (!Arrays.equals(columnNames, other.columnNames)) {</span>
<span class="fc" id="L819">            return false;</span>
        }
<span class="fc bfc" id="L821" title="All 2 branches covered.">        if (resultSetConcurrency == null) {</span>
<span class="fc bfc" id="L822" title="All 2 branches covered.">            if (other.resultSetConcurrency != null) {</span>
<span class="fc" id="L823">                return false;</span>
            }
<span class="fc bfc" id="L825" title="All 2 branches covered.">        } else if (!resultSetConcurrency.equals(other.resultSetConcurrency)) {</span>
<span class="fc" id="L826">            return false;</span>
        }
<span class="fc bfc" id="L828" title="All 2 branches covered.">        if (resultSetHoldability == null) {</span>
<span class="fc bfc" id="L829" title="All 2 branches covered.">            if (other.resultSetHoldability != null) {</span>
<span class="fc" id="L830">                return false;</span>
            }
<span class="fc bfc" id="L832" title="All 2 branches covered.">        } else if (!resultSetHoldability.equals(other.resultSetHoldability)) {</span>
<span class="fc" id="L833">            return false;</span>
        }
<span class="fc bfc" id="L835" title="All 2 branches covered.">        if (resultSetType == null) {</span>
<span class="pc bpc" id="L836" title="1 of 2 branches missed.">            if (other.resultSetType != null) {</span>
<span class="nc" id="L837">                return false;</span>
            }
<span class="fc bfc" id="L839" title="All 2 branches covered.">        } else if (!resultSetType.equals(other.resultSetType)) {</span>
<span class="fc" id="L840">            return false;</span>
        }
<span class="fc bfc" id="L842" title="All 2 branches covered.">        if (schema == null) {</span>
<span class="pc bpc" id="L843" title="1 of 2 branches missed.">            if (other.schema != null) {</span>
<span class="nc" id="L844">                return false;</span>
            }
<span class="fc bfc" id="L846" title="All 2 branches covered.">        } else if (!schema.equals(other.schema)) {</span>
<span class="fc" id="L847">            return false;</span>
        }
<span class="pc bpc" id="L849" title="1 of 2 branches missed.">        if (sql == null) {</span>
<span class="nc bnc" id="L850" title="All 2 branches missed.">            if (other.sql != null) {</span>
<span class="nc" id="L851">                return false;</span>
            }
<span class="fc bfc" id="L853" title="All 2 branches covered.">        } else if (!sql.equals(other.sql)) {</span>
<span class="fc" id="L854">            return false;</span>
        }
<span class="fc bfc" id="L856" title="All 2 branches covered.">        if (statementType != other.statementType) {</span>
<span class="fc" id="L857">            return false;</span>
        }
<span class="fc" id="L859">        return true;</span>
    }

    /**
     * Gets a flag indicating whether auto-generated keys should be returned; one of
     * &lt;code&gt;Statement.RETURN_GENERATED_KEYS&lt;/code&gt; or &lt;code&gt;Statement.NO_GENERATED_KEYS&lt;/code&gt;.
     *
     * @return a flag indicating whether auto-generated keys should be returned.
     */
    public Integer getAutoGeneratedKeys() {
<span class="fc" id="L869">        return autoGeneratedKeys;</span>
    }

    /**
     * The catalog.
     *
     * @return The catalog.
     */
    public String getCatalog() {
<span class="fc" id="L878">        return catalog;</span>
    }

    /**
     * Gets an array of column indexes indicating the columns that should be returned from the inserted row or rows.
     *
     * @return An array of column indexes.
     */
    public int[] getColumnIndexes() {
<span class="fc" id="L887">        return columnIndexes;</span>
    }

    /**
     * Gets an array of column names indicating the columns that should be returned from the inserted row or rows.
     *
     * @return An array of column names.
     */
    public String[] getColumnNames() {
<span class="fc" id="L896">        return columnNames;</span>
    }

    /**
     * Gets the result set concurrency type; one of &lt;code&gt;ResultSet.CONCUR_READ_ONLY&lt;/code&gt; or
     * &lt;code&gt;ResultSet.CONCUR_UPDATABLE&lt;/code&gt;.
     *
     * @return The result set concurrency type.
     */
    public Integer getResultSetConcurrency() {
<span class="fc" id="L906">        return resultSetConcurrency;</span>
    }

    /**
     * Gets the result set holdability, one of the following &lt;code&gt;ResultSet&lt;/code&gt; constants:
     * &lt;code&gt;ResultSet.HOLD_CURSORS_OVER_COMMIT&lt;/code&gt; or &lt;code&gt;ResultSet.CLOSE_CURSORS_AT_COMMIT&lt;/code&gt;.
     *
     * @return The result set holdability.
     */
    public Integer getResultSetHoldability() {
<span class="fc" id="L916">        return resultSetHoldability;</span>
    }

    /**
     * Gets the result set type, one of &lt;code&gt;ResultSet.TYPE_FORWARD_ONLY&lt;/code&gt;,
     * &lt;code&gt;ResultSet.TYPE_SCROLL_INSENSITIVE&lt;/code&gt;, or &lt;code&gt;ResultSet.TYPE_SCROLL_SENSITIVE&lt;/code&gt;.
     *
     * @return the result set type.
     */
    public Integer getResultSetType() {
<span class="fc" id="L926">        return resultSetType;</span>
    }

    /**
     * The schema.
     *
     * @return The catalog.
     */
    public String getSchema() {
<span class="fc" id="L935">        return schema;</span>
    }

    /**
     * Gets the SQL statement.
     *
     * @return the SQL statement.
     */
    public String getSql() {
<span class="fc" id="L944">        return sql;</span>
    }

    /**
     * The SQL statement type.
     *
     * @return The SQL statement type.
     */
    public StatementType getStmtType() {
<span class="fc" id="L953">        return statementType;</span>
    }

    @Override
    public int hashCode() {
<span class="fc" id="L958">        final int prime = 31;</span>
<span class="fc" id="L959">        int result = 1;</span>
<span class="fc bfc" id="L960" title="All 2 branches covered.">        result = prime * result + ((autoGeneratedKeys == null) ? 0 : autoGeneratedKeys.hashCode());</span>
<span class="fc bfc" id="L961" title="All 2 branches covered.">        result = prime * result + ((catalog == null) ? 0 : catalog.hashCode());</span>
<span class="fc" id="L962">        result = prime * result + Arrays.hashCode(columnIndexes);</span>
<span class="fc" id="L963">        result = prime * result + Arrays.hashCode(columnNames);</span>
<span class="fc bfc" id="L964" title="All 2 branches covered.">        result = prime * result + ((resultSetConcurrency == null) ? 0 : resultSetConcurrency.hashCode());</span>
<span class="fc bfc" id="L965" title="All 2 branches covered.">        result = prime * result + ((resultSetHoldability == null) ? 0 : resultSetHoldability.hashCode());</span>
<span class="fc bfc" id="L966" title="All 2 branches covered.">        result = prime * result + ((resultSetType == null) ? 0 : resultSetType.hashCode());</span>
<span class="fc bfc" id="L967" title="All 2 branches covered.">        result = prime * result + ((schema == null) ? 0 : schema.hashCode());</span>
<span class="pc bpc" id="L968" title="1 of 2 branches missed.">        result = prime * result + ((sql == null) ? 0 : sql.hashCode());</span>
<span class="pc bpc" id="L969" title="1 of 2 branches missed.">        result = prime * result + ((statementType == null) ? 0 : statementType.hashCode());</span>
<span class="fc" id="L970">        return result;</span>
    }

    @Override
    public String toString() {
<span class="fc" id="L975">        final StringBuffer buf = new StringBuffer();</span>
<span class="fc" id="L976">        buf.append(&quot;PStmtKey: sql=&quot;);</span>
<span class="fc" id="L977">        buf.append(sql);</span>
<span class="fc" id="L978">        buf.append(&quot;, catalog=&quot;);</span>
<span class="fc" id="L979">        buf.append(catalog);</span>
<span class="fc" id="L980">        buf.append(&quot;, schema=&quot;);</span>
<span class="fc" id="L981">        buf.append(schema);</span>
<span class="fc" id="L982">        buf.append(&quot;, resultSetType=&quot;);</span>
<span class="fc" id="L983">        buf.append(resultSetType);</span>
<span class="fc" id="L984">        buf.append(&quot;, resultSetConcurrency=&quot;);</span>
<span class="fc" id="L985">        buf.append(resultSetConcurrency);</span>
<span class="fc" id="L986">        buf.append(&quot;, resultSetHoldability=&quot;);</span>
<span class="fc" id="L987">        buf.append(resultSetHoldability);</span>
<span class="fc" id="L988">        buf.append(&quot;, autoGeneratedKeys=&quot;);</span>
<span class="fc" id="L989">        buf.append(autoGeneratedKeys);</span>
<span class="fc" id="L990">        buf.append(&quot;, columnIndexes=&quot;);</span>
<span class="fc" id="L991">        buf.append(Arrays.toString(columnIndexes));</span>
<span class="fc" id="L992">        buf.append(&quot;, columnNames=&quot;);</span>
<span class="fc" id="L993">        buf.append(Arrays.toString(columnNames));</span>
<span class="fc" id="L994">        buf.append(&quot;, statementType=&quot;);</span>
<span class="fc" id="L995">        buf.append(statementType);</span>
<span class="fc" id="L996">        return buf.toString();</span>
    }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.2.201808211720</span></div></body></html>