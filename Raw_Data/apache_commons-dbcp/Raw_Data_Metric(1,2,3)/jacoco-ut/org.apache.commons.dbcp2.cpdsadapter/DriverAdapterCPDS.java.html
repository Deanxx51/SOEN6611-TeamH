<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>DriverAdapterCPDS.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">Apache Commons DBCP</a> &gt; <a href="index.source.html" class="el_package">org.apache.commons.dbcp2.cpdsadapter</a> &gt; <span class="el_source">DriverAdapterCPDS.java</span></div><h1>DriverAdapterCPDS.java</h1><pre class="source lang-java linenums">/*
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the &quot;License&quot;); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package org.apache.commons.dbcp2.cpdsadapter;

import java.io.PrintWriter;
import java.io.Serializable;
import java.sql.DriverManager;
import java.sql.SQLException;
import java.sql.SQLFeatureNotSupportedException;
import java.util.Hashtable;
import java.util.Properties;
import java.util.logging.Logger;

import javax.naming.Context;
import javax.naming.Name;
import javax.naming.NamingException;
import javax.naming.RefAddr;
import javax.naming.Reference;
import javax.naming.Referenceable;
import javax.naming.StringRefAddr;
import javax.naming.spi.ObjectFactory;
import javax.sql.ConnectionPoolDataSource;
import javax.sql.PooledConnection;

import org.apache.commons.dbcp2.DelegatingPreparedStatement;
import org.apache.commons.dbcp2.PStmtKey;
import org.apache.commons.dbcp2.Utils;
import org.apache.commons.pool2.KeyedObjectPool;
import org.apache.commons.pool2.impl.BaseObjectPoolConfig;
import org.apache.commons.pool2.impl.GenericKeyedObjectPool;
import org.apache.commons.pool2.impl.GenericKeyedObjectPoolConfig;

/**
 * &lt;p&gt;
 * An adapter for JDBC drivers that do not include an implementation of {@link javax.sql.ConnectionPoolDataSource}, but
 * still include a {@link java.sql.DriverManager} implementation. &lt;code&gt;ConnectionPoolDataSource&lt;/code&gt;s are not used
 * within general applications. They are used by &lt;code&gt;DataSource&lt;/code&gt; implementations that pool
 * &lt;code&gt;Connection&lt;/code&gt;s, such as {@link org.apache.commons.dbcp2.datasources.SharedPoolDataSource}. A J2EE container
 * will normally provide some method of initializing the &lt;code&gt;ConnectionPoolDataSource&lt;/code&gt; whose attributes are
 * presented as bean getters/setters and then deploying it via JNDI. It is then available as a source of physical
 * connections to the database, when the pooling &lt;code&gt;DataSource&lt;/code&gt; needs to create a new physical connection.
 * &lt;/p&gt;
 * &lt;p&gt;
 * Although normally used within a JNDI environment, the DriverAdapterCPDS can be instantiated and initialized as any
 * bean and then attached directly to a pooling &lt;code&gt;DataSource&lt;/code&gt;. &lt;code&gt;Jdbc2PoolDataSource&lt;/code&gt; can use the
 * &lt;code&gt;ConnectionPoolDataSource&lt;/code&gt; with or without the use of JNDI.
 * &lt;/p&gt;
 * &lt;p&gt;
 * The DriverAdapterCPDS also provides &lt;code&gt;PreparedStatement&lt;/code&gt; pooling which is not generally available in jdbc2
 * &lt;code&gt;ConnectionPoolDataSource&lt;/code&gt; implementation, but is addressed within the jdbc3 specification. The
 * &lt;code&gt;PreparedStatement&lt;/code&gt; pool in DriverAdapterCPDS has been in the dbcp package for some time, but it has not
 * undergone extensive testing in the configuration used here. It should be considered experimental and can be toggled
 * with the poolPreparedStatements attribute.
 * &lt;/p&gt;
 * &lt;p&gt;
 * The &lt;a href=&quot;package-summary.html&quot;&gt;package documentation&lt;/a&gt; contains an example using catalina and JNDI. The
 * &lt;a href=&quot;../datasources/package-summary.html&quot;&gt;datasources package documentation&lt;/a&gt; shows how to use
 * &lt;code&gt;DriverAdapterCPDS&lt;/code&gt; as a source for &lt;code&gt;Jdbc2PoolDataSource&lt;/code&gt; without the use of JNDI.
 * &lt;/p&gt;
 *
 * @since 2.0
 */
public class DriverAdapterCPDS implements ConnectionPoolDataSource, Referenceable, Serializable, ObjectFactory {

    private static final String KEY_USER = &quot;user&quot;;

    private static final String KEY_PASSWORD = &quot;password&quot;;

    private static final long serialVersionUID = -4820523787212147844L;

    private static final String GET_CONNECTION_CALLED = &quot;A PooledConnection was already requested from this source, &quot;
            + &quot;further initialization is not allowed.&quot;;

    /** Description */
    private String description;

    /** Url name */
    private String url;

    /** User name */
    private String userName;

    /** User password */
    private char[] userPassword;

    /** Driver class name */
    private String driver;

    /** Login TimeOut in seconds */
    private int loginTimeout;

    /** Log stream. NOT USED */
    private transient PrintWriter logWriter;

    // PreparedStatement pool properties
    private boolean poolPreparedStatements;
<span class="fc" id="L112">    private int maxIdle = 10;</span>
<span class="fc" id="L113">    private long timeBetweenEvictionRunsMillis = BaseObjectPoolConfig.DEFAULT_TIME_BETWEEN_EVICTION_RUNS_MILLIS;</span>
<span class="fc" id="L114">    private int numTestsPerEvictionRun = -1;</span>
<span class="fc" id="L115">    private int minEvictableIdleTimeMillis = -1;</span>
<span class="fc" id="L116">    private int maxPreparedStatements = -1;</span>

    /** Whether or not getConnection has been called */
    private volatile boolean getConnectionCalled;

    /** Connection properties passed to JDBC Driver */
    private Properties connectionProperties;

    static {
        // Attempt to prevent deadlocks - see DBCP - 272
<span class="fc" id="L126">        DriverManager.getDrivers();</span>
<span class="fc" id="L127">    }</span>

    /**
     * Controls access to the underlying connection
     */
    private boolean accessToUnderlyingConnectionAllowed;

    /**
     * Default no-arg constructor for Serialization
     */
<span class="fc" id="L137">    public DriverAdapterCPDS() {</span>
<span class="fc" id="L138">    }</span>

    /**
     * Attempts to establish a database connection using the default user and password.
     */
    @Override
    public PooledConnection getPooledConnection() throws SQLException {
<span class="fc" id="L145">        return getPooledConnection(getUser(), getPassword());</span>
    }

    /**
     * Attempt to establish a database connection.
     *
     * @param pooledUserName
     *            name to be used for the connection
     * @param pooledUserPassword
     *            password to be used fur the connection
     */
    @Override
    public PooledConnection getPooledConnection(final String pooledUserName, final String pooledUserPassword)
            throws SQLException {
<span class="fc" id="L159">        getConnectionCalled = true;</span>
<span class="fc" id="L160">        PooledConnectionImpl pooledConnection = null;</span>
        // Workaround for buggy WebLogic 5.1 classloader - ignore the exception upon first invocation.
        try {
<span class="fc bfc" id="L163" title="All 2 branches covered.">            if (connectionProperties != null) {</span>
<span class="fc" id="L164">                update(connectionProperties, KEY_USER, pooledUserName);</span>
<span class="fc" id="L165">                update(connectionProperties, KEY_PASSWORD, pooledUserPassword);</span>
<span class="fc" id="L166">                pooledConnection = new PooledConnectionImpl(</span>
<span class="fc" id="L167">                        DriverManager.getConnection(getUrl(), connectionProperties));</span>
            } else {
<span class="fc" id="L169">                pooledConnection = new PooledConnectionImpl(</span>
<span class="fc" id="L170">                        DriverManager.getConnection(getUrl(), pooledUserName, pooledUserPassword));</span>
            }
<span class="fc" id="L172">            pooledConnection.setAccessToUnderlyingConnectionAllowed(isAccessToUnderlyingConnectionAllowed());</span>
<span class="nc" id="L173">        } catch (final ClassCircularityError e) {</span>
<span class="nc bnc" id="L174" title="All 2 branches missed.">            if (connectionProperties != null) {</span>
<span class="nc" id="L175">                pooledConnection = new PooledConnectionImpl(</span>
<span class="nc" id="L176">                        DriverManager.getConnection(getUrl(), connectionProperties));</span>
            } else {
<span class="nc" id="L178">                pooledConnection = new PooledConnectionImpl(</span>
<span class="nc" id="L179">                        DriverManager.getConnection(getUrl(), pooledUserName, pooledUserPassword));</span>
            }
<span class="nc" id="L181">            pooledConnection.setAccessToUnderlyingConnectionAllowed(isAccessToUnderlyingConnectionAllowed());</span>
<span class="fc" id="L182">        }</span>
<span class="fc" id="L183">        KeyedObjectPool&lt;PStmtKey, DelegatingPreparedStatement&gt; stmtPool = null;</span>
<span class="fc bfc" id="L184" title="All 2 branches covered.">        if (isPoolPreparedStatements()) {</span>
<span class="fc" id="L185">            final GenericKeyedObjectPoolConfig&lt;DelegatingPreparedStatement&gt; config = new GenericKeyedObjectPoolConfig&lt;&gt;();</span>
<span class="fc" id="L186">            config.setMaxTotalPerKey(Integer.MAX_VALUE);</span>
<span class="fc" id="L187">            config.setBlockWhenExhausted(false);</span>
<span class="fc" id="L188">            config.setMaxWaitMillis(0);</span>
<span class="fc" id="L189">            config.setMaxIdlePerKey(getMaxIdle());</span>
<span class="fc bfc" id="L190" title="All 2 branches covered.">            if (getMaxPreparedStatements() &lt;= 0) {</span>
                // since there is no limit, create a prepared statement pool with an eviction thread;
                // evictor settings are the same as the connection pool settings.
<span class="fc" id="L193">                config.setTimeBetweenEvictionRunsMillis(getTimeBetweenEvictionRunsMillis());</span>
<span class="fc" id="L194">                config.setNumTestsPerEvictionRun(getNumTestsPerEvictionRun());</span>
<span class="fc" id="L195">                config.setMinEvictableIdleTimeMillis(getMinEvictableIdleTimeMillis());</span>
            } else {
                // since there is a limit, create a prepared statement pool without an eviction thread;
                // pool has LRU functionality so when the limit is reached, 15% of the pool is cleared.
                // see org.apache.commons.pool2.impl.GenericKeyedObjectPool.clearOldest method
<span class="fc" id="L200">                config.setMaxTotal(getMaxPreparedStatements());</span>
<span class="fc" id="L201">                config.setTimeBetweenEvictionRunsMillis(-1);</span>
<span class="fc" id="L202">                config.setNumTestsPerEvictionRun(0);</span>
<span class="fc" id="L203">                config.setMinEvictableIdleTimeMillis(0);</span>
            }
<span class="fc" id="L205">            stmtPool = new GenericKeyedObjectPool&lt;&gt;(pooledConnection, config);</span>
<span class="fc" id="L206">            pooledConnection.setStatementPool(stmtPool);</span>
        }
<span class="fc" id="L208">        return pooledConnection;</span>
    }

    @Override
    public Logger getParentLogger() throws SQLFeatureNotSupportedException {
<span class="fc" id="L213">        throw new SQLFeatureNotSupportedException();</span>
    }

    // ----------------------------------------------------------------------
    // Referenceable implementation

    /**
     * &lt;CODE&gt;Referenceable&lt;/CODE&gt; implementation.
     */
    @Override
    public Reference getReference() throws NamingException {
        // this class implements its own factory
<span class="fc" id="L225">        final String factory = getClass().getName();</span>

<span class="fc" id="L227">        final Reference ref = new Reference(getClass().getName(), factory, null);</span>

<span class="fc" id="L229">        ref.add(new StringRefAddr(&quot;description&quot;, getDescription()));</span>
<span class="fc" id="L230">        ref.add(new StringRefAddr(&quot;driver&quot;, getDriver()));</span>
<span class="fc" id="L231">        ref.add(new StringRefAddr(&quot;loginTimeout&quot;, String.valueOf(getLoginTimeout())));</span>
<span class="fc" id="L232">        ref.add(new StringRefAddr(KEY_PASSWORD, getPassword()));</span>
<span class="fc" id="L233">        ref.add(new StringRefAddr(KEY_USER, getUser()));</span>
<span class="fc" id="L234">        ref.add(new StringRefAddr(&quot;url&quot;, getUrl()));</span>

<span class="fc" id="L236">        ref.add(new StringRefAddr(&quot;poolPreparedStatements&quot;, String.valueOf(isPoolPreparedStatements())));</span>
<span class="fc" id="L237">        ref.add(new StringRefAddr(&quot;maxIdle&quot;, String.valueOf(getMaxIdle())));</span>
<span class="fc" id="L238">        ref.add(new StringRefAddr(&quot;timeBetweenEvictionRunsMillis&quot;, String.valueOf(getTimeBetweenEvictionRunsMillis())));</span>
<span class="fc" id="L239">        ref.add(new StringRefAddr(&quot;numTestsPerEvictionRun&quot;, String.valueOf(getNumTestsPerEvictionRun())));</span>
<span class="fc" id="L240">        ref.add(new StringRefAddr(&quot;minEvictableIdleTimeMillis&quot;, String.valueOf(getMinEvictableIdleTimeMillis())));</span>
<span class="fc" id="L241">        ref.add(new StringRefAddr(&quot;maxPreparedStatements&quot;, String.valueOf(getMaxPreparedStatements())));</span>

<span class="fc" id="L243">        return ref;</span>
    }

    // ----------------------------------------------------------------------
    // ObjectFactory implementation

    /**
     * implements ObjectFactory to create an instance of this class
     */
    @Override
    public Object getObjectInstance(final Object refObj, final Name name, final Context context,
            final Hashtable&lt;?, ?&gt; env) throws Exception {
        // The spec says to return null if we can't create an instance
        // of the reference
<span class="fc" id="L257">        DriverAdapterCPDS cpds = null;</span>
<span class="fc bfc" id="L258" title="All 2 branches covered.">        if (refObj instanceof Reference) {</span>
<span class="fc" id="L259">            final Reference ref = (Reference) refObj;</span>
<span class="pc bpc" id="L260" title="1 of 2 branches missed.">            if (ref.getClassName().equals(getClass().getName())) {</span>
<span class="fc" id="L261">                RefAddr ra = ref.get(&quot;description&quot;);</span>
<span class="pc bpc" id="L262" title="1 of 4 branches missed.">                if (ra != null &amp;&amp; ra.getContent() != null) {</span>
<span class="fc" id="L263">                    setDescription(ra.getContent().toString());</span>
                }

<span class="fc" id="L266">                ra = ref.get(&quot;driver&quot;);</span>
<span class="pc bpc" id="L267" title="2 of 4 branches missed.">                if (ra != null &amp;&amp; ra.getContent() != null) {</span>
<span class="fc" id="L268">                    setDriver(ra.getContent().toString());</span>
                }
<span class="fc" id="L270">                ra = ref.get(&quot;url&quot;);</span>
<span class="pc bpc" id="L271" title="2 of 4 branches missed.">                if (ra != null &amp;&amp; ra.getContent() != null) {</span>
<span class="fc" id="L272">                    setUrl(ra.getContent().toString());</span>
                }
<span class="fc" id="L274">                ra = ref.get(KEY_USER);</span>
<span class="pc bpc" id="L275" title="2 of 4 branches missed.">                if (ra != null &amp;&amp; ra.getContent() != null) {</span>
<span class="fc" id="L276">                    setUser(ra.getContent().toString());</span>
                }
<span class="fc" id="L278">                ra = ref.get(KEY_PASSWORD);</span>
<span class="pc bpc" id="L279" title="2 of 4 branches missed.">                if (ra != null &amp;&amp; ra.getContent() != null) {</span>
<span class="fc" id="L280">                    setPassword(ra.getContent().toString());</span>
                }

<span class="fc" id="L283">                ra = ref.get(&quot;poolPreparedStatements&quot;);</span>
<span class="pc bpc" id="L284" title="2 of 4 branches missed.">                if (ra != null &amp;&amp; ra.getContent() != null) {</span>
<span class="fc" id="L285">                    setPoolPreparedStatements(Boolean.valueOf(ra.getContent().toString()).booleanValue());</span>
                }
<span class="fc" id="L287">                ra = ref.get(&quot;maxIdle&quot;);</span>
<span class="pc bpc" id="L288" title="2 of 4 branches missed.">                if (ra != null &amp;&amp; ra.getContent() != null) {</span>
<span class="fc" id="L289">                    setMaxIdle(Integer.parseInt(ra.getContent().toString()));</span>
                }

<span class="fc" id="L292">                ra = ref.get(&quot;timeBetweenEvictionRunsMillis&quot;);</span>
<span class="pc bpc" id="L293" title="2 of 4 branches missed.">                if (ra != null &amp;&amp; ra.getContent() != null) {</span>
<span class="fc" id="L294">                    setTimeBetweenEvictionRunsMillis(Integer.parseInt(ra.getContent().toString()));</span>
                }

<span class="fc" id="L297">                ra = ref.get(&quot;numTestsPerEvictionRun&quot;);</span>
<span class="pc bpc" id="L298" title="2 of 4 branches missed.">                if (ra != null &amp;&amp; ra.getContent() != null) {</span>
<span class="fc" id="L299">                    setNumTestsPerEvictionRun(Integer.parseInt(ra.getContent().toString()));</span>
                }

<span class="fc" id="L302">                ra = ref.get(&quot;minEvictableIdleTimeMillis&quot;);</span>
<span class="pc bpc" id="L303" title="2 of 4 branches missed.">                if (ra != null &amp;&amp; ra.getContent() != null) {</span>
<span class="fc" id="L304">                    setMinEvictableIdleTimeMillis(Integer.parseInt(ra.getContent().toString()));</span>
                }
<span class="fc" id="L306">                ra = ref.get(&quot;maxPreparedStatements&quot;);</span>
<span class="pc bpc" id="L307" title="2 of 4 branches missed.">                if (ra != null &amp;&amp; ra.getContent() != null) {</span>
<span class="fc" id="L308">                    setMaxPreparedStatements(Integer.parseInt(ra.getContent().toString()));</span>
                }

<span class="fc" id="L311">                ra = ref.get(&quot;accessToUnderlyingConnectionAllowed&quot;);</span>
<span class="pc bpc" id="L312" title="3 of 4 branches missed.">                if (ra != null &amp;&amp; ra.getContent() != null) {</span>
<span class="nc" id="L313">                    setAccessToUnderlyingConnectionAllowed(Boolean.valueOf(ra.getContent().toString()).booleanValue());</span>
                }

<span class="fc" id="L316">                cpds = this;</span>
            }
        }
<span class="fc" id="L319">        return cpds;</span>
    }

    /**
     * Throws an IllegalStateException, if a PooledConnection has already been requested.
     */
    private void assertInitializationAllowed() throws IllegalStateException {
<span class="fc bfc" id="L326" title="All 2 branches covered.">        if (getConnectionCalled) {</span>
<span class="fc" id="L327">            throw new IllegalStateException(GET_CONNECTION_CALLED);</span>
        }
<span class="fc" id="L329">    }</span>

    // ----------------------------------------------------------------------
    // Properties

    /**
     * Gets the connection properties passed to the JDBC driver.
     *
     * @return the JDBC connection properties used when creating connections.
     */
    public Properties getConnectionProperties() {
<span class="fc" id="L340">        return connectionProperties;</span>
    }

    /**
     * &lt;p&gt;
     * Sets the connection properties passed to the JDBC driver.
     * &lt;/p&gt;
     *
     * &lt;p&gt;
     * If &lt;code&gt;props&lt;/code&gt; contains &quot;user&quot; and/or &quot;password&quot; properties, the corresponding instance properties are
     * set. If these properties are not present, they are filled in using {@link #getUser()}, {@link #getPassword()}
     * when {@link #getPooledConnection()} is called, or using the actual parameters to the method call when
     * {@link #getPooledConnection(String, String)} is called. Calls to {@link #setUser(String)} or
     * {@link #setPassword(String)} overwrite the values of these properties if &lt;code&gt;connectionProperties&lt;/code&gt; is not
     * null.
     * &lt;/p&gt;
     *
     * @param props
     *            Connection properties to use when creating new connections.
     * @throws IllegalStateException
     *             if {@link #getPooledConnection()} has been called
     */
    public void setConnectionProperties(final Properties props) {
<span class="fc" id="L363">        assertInitializationAllowed();</span>
<span class="fc" id="L364">        connectionProperties = props;</span>
<span class="fc bfc" id="L365" title="All 2 branches covered.">        if (connectionProperties != null) {</span>
<span class="fc bfc" id="L366" title="All 2 branches covered.">            if (connectionProperties.containsKey(KEY_USER)) {</span>
<span class="fc" id="L367">                setUser(connectionProperties.getProperty(KEY_USER));</span>
            }
<span class="fc bfc" id="L369" title="All 2 branches covered.">            if (connectionProperties.containsKey(KEY_PASSWORD)) {</span>
<span class="fc" id="L370">                setPassword(connectionProperties.getProperty(KEY_PASSWORD));</span>
            }
        }
<span class="fc" id="L373">    }</span>

    /**
     * Gets the value of description. This property is here for use by the code which will deploy this datasource. It is
     * not used internally.
     *
     * @return value of description, may be null.
     * @see #setDescription(String)
     */
    public String getDescription() {
<span class="fc" id="L383">        return description;</span>
    }

    /**
     * Sets the value of description. This property is here for use by the code which will deploy this datasource. It is
     * not used internally.
     *
     * @param v
     *            Value to assign to description.
     */
    public void setDescription(final String v) {
<span class="fc" id="L394">        this.description = v;</span>
<span class="fc" id="L395">    }</span>

    /**
     * Gets the value of password for the default user.
     *
     * @return value of password.
     * @since 2.4.0
     */
    public char[] getPasswordCharArray() {
<span class="fc" id="L404">        return userPassword;</span>
    }

    /**
     * Gets the value of password for the default user.
     *
     * @return value of password.
     */
    public String getPassword() {
<span class="fc" id="L413">        return Utils.toString(userPassword);</span>
    }

    /**
     * Sets the value of password for the default user.
     *
     * @param userPassword
     *            Value to assign to password.
     * @throws IllegalStateException
     *             if {@link #getPooledConnection()} has been called
     */
    public void setPassword(final char[] userPassword) {
<span class="fc" id="L425">        assertInitializationAllowed();</span>
<span class="fc" id="L426">        this.userPassword = Utils.clone(userPassword);</span>
<span class="fc" id="L427">        update(connectionProperties, KEY_PASSWORD, Utils.toString(this.userPassword));</span>
<span class="fc" id="L428">    }</span>

    /**
     * Sets the value of password for the default user.
     *
     * @param userPassword
     *            Value to assign to password.
     * @throws IllegalStateException
     *             if {@link #getPooledConnection()} has been called
     */
    public void setPassword(final String userPassword) {
<span class="fc" id="L439">        assertInitializationAllowed();</span>
<span class="fc" id="L440">        this.userPassword = Utils.toCharArray(userPassword);</span>
<span class="fc" id="L441">        update(connectionProperties, KEY_PASSWORD, userPassword);</span>
<span class="fc" id="L442">    }</span>

    /**
     * Gets the value of url used to locate the database for this datasource.
     *
     * @return value of url.
     */
    public String getUrl() {
<span class="fc" id="L450">        return url;</span>
    }

    /**
     * Sets the value of URL string used to locate the database for this datasource.
     *
     * @param v
     *            Value to assign to url.
     * @throws IllegalStateException
     *             if {@link #getPooledConnection()} has been called
     */
    public void setUrl(final String v) {
<span class="fc" id="L462">        assertInitializationAllowed();</span>
<span class="fc" id="L463">        this.url = v;</span>
<span class="fc" id="L464">    }</span>

    /**
     * Gets the value of default user (login or user name).
     *
     * @return value of user.
     */
    public String getUser() {
<span class="fc" id="L472">        return userName;</span>
    }

    /**
     * Sets the value of default user (login or user name).
     *
     * @param v
     *            Value to assign to user.
     * @throws IllegalStateException
     *             if {@link #getPooledConnection()} has been called
     */
    public void setUser(final String v) {
<span class="fc" id="L484">        assertInitializationAllowed();</span>
<span class="fc" id="L485">        this.userName = v;</span>
<span class="fc" id="L486">        update(connectionProperties, KEY_USER, v);</span>
<span class="fc" id="L487">    }</span>

    /**
     * Gets the driver class name.
     *
     * @return value of driver.
     */
    public String getDriver() {
<span class="fc" id="L495">        return driver;</span>
    }

    /**
     * Sets the driver class name. Setting the driver class name cause the driver to be registered with the
     * DriverManager.
     *
     * @param v
     *            Value to assign to driver.
     * @throws IllegalStateException
     *             if {@link #getPooledConnection()} has been called
     * @throws ClassNotFoundException
     *             if the class cannot be located
     */
    public void setDriver(final String v) throws ClassNotFoundException {
<span class="fc" id="L510">        assertInitializationAllowed();</span>
<span class="fc" id="L511">        this.driver = v;</span>
        // make sure driver is registered
<span class="fc" id="L513">        Class.forName(v);</span>
<span class="fc" id="L514">    }</span>

    /**
     * Gets the maximum time in seconds that this data source can wait while attempting to connect to a database. NOT
     * USED.
     */
    @Override
    public int getLoginTimeout() {
<span class="fc" id="L522">        return loginTimeout;</span>
    }

    /**
     * Gets the log writer for this data source. NOT USED.
     */
    @Override
    public PrintWriter getLogWriter() {
<span class="fc" id="L530">        return logWriter;</span>
    }

    /**
     * Sets the maximum time in seconds that this data source will wait while attempting to connect to a database. NOT
     * USED.
     */
    @Override
    public void setLoginTimeout(final int seconds) {
<span class="fc" id="L539">        loginTimeout = seconds;</span>
<span class="fc" id="L540">    }</span>

    /**
     * Sets the log writer for this data source. NOT USED.
     */
    @Override
    public void setLogWriter(final PrintWriter out) {
<span class="fc" id="L547">        logWriter = out;</span>
<span class="fc" id="L548">    }</span>

    // ------------------------------------------------------------------
    // PreparedStatement pool properties

    /**
     * Flag to toggle the pooling of &lt;code&gt;PreparedStatement&lt;/code&gt;s
     *
     * @return value of poolPreparedStatements.
     */
    public boolean isPoolPreparedStatements() {
<span class="fc" id="L559">        return poolPreparedStatements;</span>
    }

    /**
     * Flag to toggle the pooling of &lt;code&gt;PreparedStatement&lt;/code&gt;s
     *
     * @param poolPreparedStatements
     *            true to pool statements.
     * @throws IllegalStateException
     *             if {@link #getPooledConnection()} has been called
     */
    public void setPoolPreparedStatements(final boolean poolPreparedStatements) {
<span class="fc" id="L571">        assertInitializationAllowed();</span>
<span class="fc" id="L572">        this.poolPreparedStatements = poolPreparedStatements;</span>
<span class="fc" id="L573">    }</span>

    /**
     * Gets the maximum number of statements that can remain idle in the pool, without extra ones being released, or
     * negative for no limit.
     *
     * @return the value of maxIdle
     */
    public int getMaxIdle() {
<span class="fc" id="L582">        return this.maxIdle;</span>
    }

    /**
     * Gets the maximum number of statements that can remain idle in the pool, without extra ones being released, or
     * negative for no limit.
     *
     * @param maxIdle
     *            The maximum number of statements that can remain idle
     * @throws IllegalStateException
     *             if {@link #getPooledConnection()} has been called
     */
    public void setMaxIdle(final int maxIdle) {
<span class="fc" id="L595">        assertInitializationAllowed();</span>
<span class="fc" id="L596">        this.maxIdle = maxIdle;</span>
<span class="fc" id="L597">    }</span>

    /**
     * Gets the number of milliseconds to sleep between runs of the idle object evictor thread. When non-positive, no
     * idle object evictor thread will be run.
     *
     * @return the value of the evictor thread timer
     * @see #setTimeBetweenEvictionRunsMillis(long)
     */
    public long getTimeBetweenEvictionRunsMillis() {
<span class="fc" id="L607">        return timeBetweenEvictionRunsMillis;</span>
    }

    /**
     * Sets the number of milliseconds to sleep between runs of the idle object evictor thread. When non-positive, no
     * idle object evictor thread will be run.
     *
     * @param timeBetweenEvictionRunsMillis
     *            The number of milliseconds to sleep between runs of the idle object evictor thread. When non-positive,
     *            no idle object evictor thread will be run.
     * @see #getTimeBetweenEvictionRunsMillis()
     * @throws IllegalStateException
     *             if {@link #getPooledConnection()} has been called
     */
    public void setTimeBetweenEvictionRunsMillis(final long timeBetweenEvictionRunsMillis) {
<span class="fc" id="L622">        assertInitializationAllowed();</span>
<span class="fc" id="L623">        this.timeBetweenEvictionRunsMillis = timeBetweenEvictionRunsMillis;</span>
<span class="fc" id="L624">    }</span>

    /**
     * Gets the number of statements to examine during each run of the idle object evictor thread (if any.)
     *
     * @see #setNumTestsPerEvictionRun
     * @see #setTimeBetweenEvictionRunsMillis
     * @return the number of statements to examine during each run of the idle object evictor thread (if any.)
     */
    public int getNumTestsPerEvictionRun() {
<span class="fc" id="L634">        return numTestsPerEvictionRun;</span>
    }

    /**
     * Sets the number of statements to examine during each run of the idle object evictor thread (if any).
     * &lt;p&gt;
     * When a negative value is supplied, &lt;tt&gt;ceil({*link #numIdle})/abs({*link #getNumTestsPerEvictionRun})&lt;/tt&gt; tests
     * will be run. I.e., when the value is &lt;i&gt;-n&lt;/i&gt;, roughly one &lt;i&gt;n&lt;/i&gt;th of the idle objects will be tested per
     * run.
     * &lt;/p&gt;
     *
     * @param numTestsPerEvictionRun
     *            number of statements to examine per run
     * @see #getNumTestsPerEvictionRun()
     * @see #setTimeBetweenEvictionRunsMillis(long)
     * @throws IllegalStateException
     *             if {@link #getPooledConnection()} has been called
     */
    public void setNumTestsPerEvictionRun(final int numTestsPerEvictionRun) {
<span class="fc" id="L653">        assertInitializationAllowed();</span>
<span class="fc" id="L654">        this.numTestsPerEvictionRun = numTestsPerEvictionRun;</span>
<span class="fc" id="L655">    }</span>

    /**
     * Gets the minimum amount of time a statement may sit idle in the pool before it is eligible for eviction by the
     * idle object evictor (if any).
     *
     * @see #setMinEvictableIdleTimeMillis
     * @see #setTimeBetweenEvictionRunsMillis
     * @return the minimum amount of time a statement may sit idle in the pool.
     */
    public int getMinEvictableIdleTimeMillis() {
<span class="fc" id="L666">        return minEvictableIdleTimeMillis;</span>
    }

    /**
     * Sets the minimum amount of time a statement may sit idle in the pool before it is eligible for eviction by the
     * idle object evictor (if any). When non-positive, no objects will be evicted from the pool due to idle time alone.
     *
     * @param minEvictableIdleTimeMillis
     *            minimum time to set (in ms)
     * @see #getMinEvictableIdleTimeMillis()
     * @see #setTimeBetweenEvictionRunsMillis(long)
     * @throws IllegalStateException
     *             if {@link #getPooledConnection()} has been called
     */
    public void setMinEvictableIdleTimeMillis(final int minEvictableIdleTimeMillis) {
<span class="fc" id="L681">        assertInitializationAllowed();</span>
<span class="fc" id="L682">        this.minEvictableIdleTimeMillis = minEvictableIdleTimeMillis;</span>
<span class="fc" id="L683">    }</span>

    /**
     * Returns the value of the accessToUnderlyingConnectionAllowed property.
     *
     * @return true if access to the underlying is allowed, false otherwise.
     */
    public synchronized boolean isAccessToUnderlyingConnectionAllowed() {
<span class="fc" id="L691">        return this.accessToUnderlyingConnectionAllowed;</span>
    }

    /**
     * Sets the value of the accessToUnderlyingConnectionAllowed property. It controls if the PoolGuard allows access to
     * the underlying connection. (Default: false)
     *
     * @param allow
     *            Access to the underlying connection is granted when true.
     */
    public synchronized void setAccessToUnderlyingConnectionAllowed(final boolean allow) {
<span class="fc" id="L702">        this.accessToUnderlyingConnectionAllowed = allow;</span>
<span class="fc" id="L703">    }</span>

    /**
     * Gets the maximum number of prepared statements.
     *
     * @return maxPrepartedStatements value
     */
    public int getMaxPreparedStatements() {
<span class="fc" id="L711">        return maxPreparedStatements;</span>
    }

    /**
     * Sets the maximum number of prepared statements.
     *
     * @param maxPreparedStatements
     *            the new maximum number of prepared statements
     */
    public void setMaxPreparedStatements(final int maxPreparedStatements) {
<span class="fc" id="L721">        this.maxPreparedStatements = maxPreparedStatements;</span>
<span class="fc" id="L722">    }</span>

    private void update(final Properties properties, final String key, final String value) {
<span class="fc bfc" id="L725" title="All 2 branches covered.">        if (properties != null) {</span>
<span class="fc bfc" id="L726" title="All 2 branches covered.">            if (value == null) {</span>
<span class="fc" id="L727">                properties.remove(key);</span>
            } else {
<span class="fc" id="L729">                properties.setProperty(key, value);</span>
            }
        }
<span class="fc" id="L732">    }</span>

    /**
     * Does not print the userName and userPassword field nor the 'user' or 'password' in the connectionProperties.
     *
     * @since 2.6.0
     */
    @Override
    public synchronized String toString() {
<span class="nc" id="L741">        final StringBuilder builder = new StringBuilder(super.toString());</span>
<span class="nc" id="L742">        builder.append(&quot;[description=&quot;);</span>
<span class="nc" id="L743">        builder.append(description);</span>
<span class="nc" id="L744">        builder.append(&quot;, url=&quot;);</span>
        // TODO What if the connection string contains a 'user' or 'password' query parameter but that connection string is not in a legal URL format?
<span class="nc" id="L746">        builder.append(url);</span>
<span class="nc" id="L747">        builder.append(&quot;, driver=&quot;);</span>
<span class="nc" id="L748">        builder.append(driver);</span>
<span class="nc" id="L749">        builder.append(&quot;, loginTimeout=&quot;);</span>
<span class="nc" id="L750">        builder.append(loginTimeout);</span>
<span class="nc" id="L751">        builder.append(&quot;, poolPreparedStatements=&quot;);</span>
<span class="nc" id="L752">        builder.append(poolPreparedStatements);</span>
<span class="nc" id="L753">        builder.append(&quot;, maxIdle=&quot;);</span>
<span class="nc" id="L754">        builder.append(maxIdle);</span>
<span class="nc" id="L755">        builder.append(&quot;, timeBetweenEvictionRunsMillis=&quot;);</span>
<span class="nc" id="L756">        builder.append(timeBetweenEvictionRunsMillis);</span>
<span class="nc" id="L757">        builder.append(&quot;, numTestsPerEvictionRun=&quot;);</span>
<span class="nc" id="L758">        builder.append(numTestsPerEvictionRun);</span>
<span class="nc" id="L759">        builder.append(&quot;, minEvictableIdleTimeMillis=&quot;);</span>
<span class="nc" id="L760">        builder.append(minEvictableIdleTimeMillis);</span>
<span class="nc" id="L761">        builder.append(&quot;, maxPreparedStatements=&quot;);</span>
<span class="nc" id="L762">        builder.append(maxPreparedStatements);</span>
<span class="nc" id="L763">        builder.append(&quot;, getConnectionCalled=&quot;);</span>
<span class="nc" id="L764">        builder.append(getConnectionCalled);</span>
<span class="nc" id="L765">        builder.append(&quot;, connectionProperties=&quot;);</span>
<span class="nc" id="L766">        Properties tmpProps = connectionProperties;</span>
<span class="nc" id="L767">        final String pwdKey = &quot;password&quot;;</span>
<span class="nc bnc" id="L768" title="All 2 branches missed.">        if (connectionProperties.contains(pwdKey)) {</span>
<span class="nc" id="L769">            tmpProps = (Properties) connectionProperties.clone();</span>
<span class="nc" id="L770">            tmpProps.remove(pwdKey);</span>
        }
<span class="nc" id="L772">        builder.append(tmpProps);</span>
<span class="nc" id="L773">        builder.append(&quot;, accessToUnderlyingConnectionAllowed=&quot;);</span>
<span class="nc" id="L774">        builder.append(accessToUnderlyingConnectionAllowed);</span>
<span class="nc" id="L775">        builder.append(&quot;]&quot;);</span>
<span class="nc" id="L776">        return builder.toString();</span>
    }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.2.201808211720</span></div></body></html>